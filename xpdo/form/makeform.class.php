<?php
/*
 * Copyright 2006, 2007, 2008, 2009 by  Jason Coward <xpdo@opengeek.com>
 * 
 * This file is part of xPDO.
 *
 * xPDO is free software; you can redistribute it and/or modify it under the
 * terms of the GNU General Public License as published by the Free Software
 * Foundation; either version 2 of the License, or (at your option) any later
 * version.
 *
 * xPDO is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR
 * A PARTICULAR PURPOSE. See the GNU General Public License for more details.
 *
 * You should have received a copy of the GNU General Public License along with
 * xPDO; if not, write to the Free Software Foundation, Inc., 59 Temple Place,
 * Suite 330, Boston, MA 02111-1307 USA
 */

/**
 * Defines a form rendering and processing class for xPDO.
 * 
 * @package xpdo
 * @subpackage form
 */

/**
 * A web form rendering and processing class for using xPDO with MODx 0.9.x.
 * 
 * Please note that MODx 0.9.x is required to render forms with MakeForm.
 * 
 * @package xpdo
 * @subpackage form
 */
class MakeForm {
    var $xpdo= null;
    var $form= null;
    var $formName= 'mfDefault';
    var $formElements= null;
    var $formTemplates= null;
    var $formTemplateCache= array();
    var $exclude= array();
    var $includeRelated= false;
    var $errorMsg= '';
    
    /**
     * The constructor for the {@link MakeForm} class.
     * 
     * @param xPDO $xpdo The {@link xPDO} class controlling this form instance.
     * @return MakeForm A MakeForm instance, or null if it could not be
     * instantiated.
     */
    function MakeForm(& $xpdo) {
        $this->xpdo= & $xpdo;
        $this->formTemplates= array(
            'form'=> 'mfDefaultForm',
            'button'=> 'mfInputButton',
            'checkbox'=> 'mfInputCheckbox',
            'hidden'=> 'mfInputHidden',
            'texthidden'=> 'mfInputHiddenWithText',
            'password'=> 'mfInputPassword',
            'radio'=> 'mfInputRadio',
            'text'=> 'mfInputText',
            'textarea'=> 'mfTextArea',
            'textonly'=> 'mfTextOnly',
            'select'=> 'mfSelect',
            'option'=> 'mfSelectOption',
            'submit'=> 'mfInputButton',
            'image'=> 'mfInputImage'
        );
    }
    
    /**
     * Sets the unique name of the form to be rendered.
     * 
     * This unique identifier can be used to set the name and id attributes of
     * the form that is generated by the {@link render()} method, once all of
     * the form elements have been defined by the {@link setFormObject()} and/or
     * {@link setFormElements()} methods.
     * 
     * @param string $name The name of the form.
     */
    function setFormName($name) {
        if (!empty($name)) $this->formName= $name;
    }
    
    /**
     * Sets the form elements automatically based on object meta data.
     * 
     * @param xPDOObject $object A valid xPDOObject or derivative.
     * @param boolean $includeRelated Determines if related objects should be
     * rendered on the form.
     */
    function setFormObject(& $object, $exclude= array (), $includeRelated= false) {
        $elements= array ();
        $this->includeRelated= $includeRelated;
        if (is_array ($exclude)) {
            $this->exclude= array_merge($this->exclude, $exclude);
        }
        $this->_setFormObject($elements, $object);
        $this->setFormElements($elements, false);
    }
    
    function _setFormObject(& $elements, & $object, $isRelated= false, $foreignKey= '') {
        if (is_object($object) && is_a($object, 'xPDOObject')) {
            $elementClass= $object->_class;
            if ($elementKey= $object->getPrimaryKey()) {
                if (is_array($elementKey)) {
                    $elementKey= implode('-', $elementKey);
                }
            } else {
                $elementKey= '';
            }
            foreach ($object->_fieldMeta as $key => $meta) {
                if (!$isRelated && in_array($key, $this->exclude)) {
                    $meta['hidden']= 1;
                } elseif ($isRelated && in_array(strtolower($elementClass) . '.' . $key, $this->exclude)) {
                    $meta['hidden']= 1;
                }
                $value= $object->get($key);
                $this->buildElementFromObject($elements, $elementClass, $elementKey, $foreignKey, $key, $value, $meta);
            }
            if ($elementKey && !$isRelated) {
                $elements[strtolower($elementClass)]= array ('type' => 'hidden', 'name' => strtolower($elementClass), 'value' => $elementKey);
            }
            if ($this->includeRelated && !empty ($object->_relatedObjects)) {
                foreach ($object->_relatedObjects as $relClass => $relDef) {
                    foreach ($relDef as $relKey => $related) {
                        if (is_array ($related)) {
                            foreach ($related as $relObj) {
                                $this->_setFormObject($elements, $relObj, true, $relKey);
                            }
                        } else {
                            $this->_setFormObject($elements, $related, true, $relKey);
                        }
                    }
                }
            }
        }
    }
    
    /**
     * Builds a single form element from meta data about a specific field.
     * 
     * @param array $elements An array of form elements, passed by reference.
     * @param string $class The name of the object class.
     * @param string $pk The primary key value(s) of the object the field
     * belongs to.
     * @param string $fk The name of the foreign key field if this is a related
     * object field.
     * @param string $k The name or key of the field.
     * @param mixed $v The value of the field.
     * @param array $meta The meta data for the field.
     */
    function buildElementFromObject(& $elements, $class, $pk, $fk, $k, $v, $meta) {
        if (is_array($elements)) {
            $elementKey= "{$class}-{$fk}-{$pk}-{$k}";
            $elementType= $this->getElementType($meta);
            $elementValue= $v !== null? $v: (isset ($meta['default'])? $meta['default']: null);
            $element['label']= $this->getLabel($k);
            $element['name']= $elementKey;
            $element['type']= $elementType;
            switch ($elementType) {
            	case 'text':
                    if (isset ($meta['precision'])) {
                        $element['maxlength']= $meta['precision'];
                    }
                    $element['value']= $elementValue;
            		break;
            	case 'password':
                    if (isset ($meta['precision'])) {
                        $element['maxlength']= $meta['precision'];
                    }
                    $element['value']= $elementValue;
            		break;
            	case 'textarea':
            		$element['rows']= '';
                    $element['cols']= '';
                    if (isset ($meta['precision'])) {
                        $element['maxlength']= $meta['precision'];
                    }
                    $element['value']= $elementValue;
            		break;
            	case 'select':
                    $opts= str_replace('\'', '', $meta['precision']);
                    $opts= explode(',', $opts);
                    $actualOpts= null;
                    $options= null;
                    foreach ($opts as $key => $opt) {
                        $actualOpts[$opt]= trim($opt);
                    }
                    $optionArray= $this->createOptions($actualOpts, $v);
                    $options= (strcasecmp($meta['dbtype'], 'enum') == 0)? $optionArray: '';
            		$element['size']= 1;
                    $element['options']= $options;
                    $element['value']= $elementValue;
            		break;
            	case 'checkbox':
                    $phpType= $meta['phptype'];
                    $element['value']= '1';
                    $element['checked']= ($elementValue == true);
            		break;
            	default:
                    $element['value']= $elementValue;
            		break;
            }
            $elements[$elementKey]= $element;
        }
    }
    
    /**
     * Gets the type of form element to render based on field meta data.
     * 
     * @param array $metaData The field metaData.
     */
    function getElementType($metaData) {
        $elementType= '';
        if (is_array($metaData) && isset ($metaData['dbtype']) && isset ($metaData['phptype'])) {
            if (isset ($metaData['hidden']) && $metaData['hidden']) {
                return 'hidden';
            }
            $dbtype= strtolower($metaData['dbtype']);
            $phptype= strtolower($metaData['phptype']);
            if ($phptype == 'password') {
                return $phptype;
            }
            $precision= isset ($metaData['precision'])? intval($metaData['precision']): 0;
            $index= isset ($metaData['index'])? $metaData['index']: '';
            $generated= isset ($metaData['generated'])? true: false; 
            switch ($dbtype) {
                case 'binary':
                    $elementType= 'checkbox';
                    break;
                case 'enum':
                    $elementType= 'select'; 
                    break;
                case 'integer':
                    if ($index == 'pk' && $generated) {
                        $elementType= 'hidden';
                    } elseif ($precision == 1) {
                        $elementType= 'checkbox';
                    } else {
                        $elementType= 'text';
                    }
                    break;
                default:
                    if ($index == 'pk' && $generated) {
                        $elementType= 'hidden';
                    } elseif ($precision > 255) {
                        $elementType= 'textarea'; 
                    } else {
                        $elementType= 'text';
                    }
                    break;
            }
        }
        return $elementType;
    }
    
    /**
     * Formats a field name, applying proper case and splitting on _.
     * 
     * @param string $string The field name or string to format as a label.
     * @return string The formatted string.
     */
    function getLabel($string) {
        $return= $string;
        if (is_string($string) && $strArray= explode('_', $string)) {
            $return= '';
            while (list($k, $v)= each($strArray)) {
                $return.= strtoupper(substr($v, 0, 1)) . substr($v, 1) . ' '; 
            }
        }
        return trim($return); 
    }
    
    /**
     * Sets the form elements from an array definition.
     * 
     * @param array $elements An array of form element definitions.
     * @param boolean $merge Determines if the elements should be merged with
     * existing elements or completely replace them.
     */
    function setFormElements($elements, $merge= true) {
        if (is_array($elements)) {
            if ($merge && is_array($this->formElements)) {
                $this->formElements= array_merge($this->formElements, $elements);
            } else {
                $this->formElements= $elements;
            }
        }
    }
    
    /**
     * Sets the form templates from an array definition.
     * 
     * @param array $templates An array of templates to apply to form fields.
     * @param boolean $merge Determines if the templates should be merged with
     * existing templates or completely replace them.
     */
    function setFormTemplates($templates, $merge= true) {
        if (is_array($templates)) {
            if ($merge && is_array($this->formTemplates)) {
                $this->formTemplates= array_merge($this->formTemplates, $templates);
            } else {
                $this->formTemplates= $templates;
            }
        }
    }
    
    function buildInput($type='text', $attributes) {
        $element= "";
        switch ($type) {
            case 'submit':
                $element= $this->parseFormElement($this->formTemplates['submit'], $attributes, '[+', '+]');
                break;
        
            case 'button':
                $element= $this->parseFormElement($this->formTemplates['button'], $attributes, '[+', '+]');
                break;
        
            case 'checkbox':
                $element= $this->parseFormElement($this->formTemplates['checkbox'], $attributes, '[+', '+]');
                break;
        
            case 'password':
                $element= $this->parseFormElement($this->formTemplates['password'], $attributes, '[+', '+]');
                break;
        
            case 'radio':
                $element= $this->parseFormElement($this->formTemplates['radio'], $attributes, '[+', '+]');
                break;
        
            default:    //default option
                $element= $this->parseFormElement($this->formTemplates["{$type}"], $attributes, '[+', '+]');
                break;
        }
        $this->form.= $element;
    } 
    
    function buildTextArea($attributes) {
        $this->form.= $this->parseFormElement($this->formTemplates['textarea'], $attributes, '[+', '+]');
    }
    
    function buildSelect($attributes, $options) {
        $attributes['selectOptions']= $this->buildSelectOptions($options);
        $this->form.= $this->parseFormElement($this->formTemplates['select'], $attributes, '[+', '+]');
    }
    
    function buildSelectOptions($options) {
        $output= "";
        if (is_array($options)) {
            foreach ($options as $option) {
                $output.= $this->parseFormElement($this->formTemplates['option'], $option, '[+', '+]');
            }
        }
        return $output;
    }

    /**
     * Builds the form and returns the resulting content.
     * 
     * @return string The output of the form.
     */
    function buildForm() {
        if (is_array($this->formElements)) {
            reset($this->formElements);
            while (list($key, $element)= each($this->formElements)) {
                if (is_array($element)) {
                    switch ($element['type']) {
                        case 'textarea':
                            $this->buildTextArea($element);
                            break;
                            
                        case 'select':
                            $this->buildSelect($element, $element['options']);
                            break;
                            
                        default:
                            $this->buildInput($element['type'], $element);
                            break;
                    }
                }
            }
        } else {
            $this->errorMsg.= '<p class="error">No form elements set!</p>';
        }
        $formOutput = $this->form;
        $this->form = null;
        return $formOutput;
    }
    
    function parseFormElement($elementName, $propArray, $prefix='[+', $suffix='+]') {
        $elementContent= '';
        if (isset($this->formTemplateCache[$elementName])) {
            $elementContent= $this->formTemplateCache[$elementName];
        } else {
            global $modx;
            $elementContent= $modx->getChunk($elementName);
        }

        if (!empty($elementContent)) {
            $valueArray= array();
            if (is_array($propArray)) {
                foreach ($propArray as $key=> $value) {
                    if (is_string($value)) $value= stripslashes($value);
                    if ($key=='label' || $key=='type' || $key=='name' || $key=='extra') {
                        $valueArray["{$prefix}{$key}{$suffix}"]= "$value";
                    } elseif ($key=='value' && ($propArray['type']=='textarea' || $propArray['type']=='textonly') || $propArray['type']=='texthidden') {
                        if (!empty($value)) $valueArray["{$prefix}{$key}{$suffix}"]= "$value";
                    } elseif ($key=='selectOptions') {
                        if (!empty($value)) $valueArray["{$prefix}{$key}{$suffix}"]= "$value";
                    } elseif ($key=='checked' || $key=='selected' || $key=='readonly' || $key=='disabled') {
                        if ($value===true) {
                            $valueArray["{$prefix}{$key}{$suffix}"]= "$key=\"$key\" ";
                        } elseif ($value) {
                            $valueArray["{$prefix}{$key}{$suffix}"]= "$key=\"$value\" ";
                        }
                    } else {
                        if (!empty($value) || $key=='value')
                            $valueArray["{$prefix}{$key}{$suffix}"]= "$key=\"$value\" ";
                        else
                            $valueArray["{$prefix}{$key}{$suffix}"]= "$key ";
                    }
                }
                $elementContent= str_replace(array_keys($valueArray), array_values($valueArray), $elementContent);
            }
        } else {
            $this->xpdo->log(XPDO_LOG_LEVEL_WARN, "MakeForm element template {$elementName} does not exist or did not produce any content.");
        }
        return $elementContent;
    }

    /*
     * Process a key=>value array and handle the appropriate data object
     * persistence tasks.
     */
    function processForm(& $object, $valueArray= array ()) {
        $success= false;
        if (is_object($object) && is_a($object, 'xPDOObject') && !empty ($valueArray)) {
            if (is_array($this->formElements)) {
                reset($this->formElements);
                while (list ($elementKey, $element)= each($this->formElements)) {
                    if ($element['type']=='checkbox' && !isset($valueArray[$elementKey])) {
                        $valueArray[$elementKey]= "0";
                    } 
                }
            }
            $this->fromArray($object, $valueArray);
//            if ($object->validate() === false) {
//                //@todo figure out how to handle validations
//            }
            $success= $object->save();
            $this->setFormObject($object, $this->exclude, $this->includeRelated);            
        }
        return $success;
    }
    
    /**
     * @todo Refactor for 1.0-beta changes.
     */
    function fromArray(& $object, $valueArray, $delim= '-') {
        $classArray= array ();
        $objClass= $object->_class;
        if (is_array($valueArray)) {
            reset($valueArray);
            while (list($key, $value)= each($valueArray)) {
                if ($keyArray= explode($delim, $key)) {
                    $className= trim($keyArray[0]);
                    $objKey= trim($keyArray[1]);
                    $index= trim($keyArray[2]);
                    $fieldName= trim($keyArray[3]);
                    if ($className && $fieldName) {
                        if (strcasecmp($className, $objClass) == 0) {
                            $classArray['baseClass'][$fieldName]= $value;
                        } else {
                            $classArray[$className][$objKey][$index][$fieldName]= $value;
                        }
                    }
                }
            }
            reset($classArray);
            while (list ($classKey, $classVal)= each($classArray)) {
                if ($classKey === 'baseClass') {
                    $object->fromArray($classVal, '', true);
                } elseif (is_array($classVal)) {
                    foreach ($classVal as $fk => $fo) {
                        if (is_array($fo)) {
                            $pk= $this->xpdo->getPK($classKey);
                            foreach ($fo as $oKey => $o) {
                                $relObj= null;
                                $fkMeta= $object->getFKDefinition($classKey, $fk);
                                if ($fkMeta && is_array($o)) {
                                    if ($fkMeta['cardinality'] == 'many' && isset ($object->_relatedObjects[$classKey][$fk][$oKey])) {
                                        $relObj= $object->_relatedObjects[$classKey][$fk][$oKey];
                                    } elseif ($fkMeta['cardinality'] == 'one' && isset ($object->_relatedObjects[$classKey][$fk])) {
                                        $relObj= $object->_relatedObjects[$classKey][$fk];
                                    }
                                }
                                if ($relObj) {
                                    $relObj->fromArray($o, '', true);
                                }
                            }
                        }
                    }
                }
            }
        }
    }
    
    function createOptions($options, $selectedOption='', $includeBlank= false) {
        $optionsArray= array();
        if ($includeBlank) {
            $optionLabel= 'Please select:';
            $optionValue= '';
            $optionsArray[]= array (
                'label'=> $optionLabel,
                'value'=> $optionValue,
                'selected'=> $optionValue==$selectedOption? true: false,
            );
        }
        if (is_array($options)) {
            reset($options);
            while (list ($optKey, $option)= each($options)) {
                if (is_array($option)) {
                    $optionLabel= $option[0];
                    $optionValue= $option[1];
                }
                else {
                    $optionLabel= $option;
                    $optionValue= $optKey;
                }
                $optionsArray[]= array(
                    'label'=> $optionLabel,
                    'value'=> $optionValue,
                    'selected'=> $optionValue==$selectedOption? true: false,
                );
            }
        }
        return $optionsArray;
    }
    
}
